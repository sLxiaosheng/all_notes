## 二叉树

### 二叉树的直径

>   给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。

### 二叉树的原理

左边递减，右边递增

每个节点只能有两个分支，左右分支顺序不可颠倒

![image-20200310131850256](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200310131850256.png)

### 我的答案：

```python
class tree_two:
    def __init__(self, val, left = None, right = None):
        self.data = val
        self.left = left
        self.right = right

A, B, C, D, E = [tree_two(x) for x in '12345']
A.left = 2
A.right = 3
B.left = 4
B.right = 5
C.right = None
C.left = None
D.right = None
D.left = None
#方便反向查找
add = {1:A,2:B,3:C,4:D,5:E}

#创建一个列表存储已经查看过的节点
covered = []
i = 0
def find_longest(node):
    def down(node):
        global covered
        global i
        #向左边不断深入
        if add[node].left:
            covered.append(add[node.left])
            i += 1
            node = node.left
            down(add[node])
        #向右边不断深入
        if add[node].right:
            covered.append(add[node.right])
            find_longest.i += 1
            node = node.right
            down(add[node])   
        return i
    return down(node)

def scan_code(code):
    long = []
    #不断深入，直到末端
    while code.right | code.left:
        if code not in covered:
            long = long.append(find_longest(code))
        #对每个节点都进行深入
        code = add[code.right | code.left]
    long = long.sort()
    return long[0]

print(scan_code(A))
```

## 官方答案：

```python
class Solution(object):
    def diameterOfBinaryTree(self, root):
        self.ans = 1
        def depth(node):
            # 访问到空节点了，返回0
            if not node: return 0
            # 左儿子为根的子树的深度
            L = depth(node.left)
            # 右儿子为根的子树的深度
            R = depth(node.right)
            # 计算d_node即L+R+1 并更新ans
            self.ans = max(self.ans, L+R+1)
            # 返回该节点为根的子树的深度
            return max(L, R) + 1

        depth(root)
        return self.ans - 1

```

